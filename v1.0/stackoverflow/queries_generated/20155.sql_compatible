
WITH RankedPosts AS (
    SELECT 
        p.Id AS PostId,
        p.Title,
        p.CreationDate,
        p.ViewCount,
        p.Score,
        ROW_NUMBER() OVER (PARTITION BY p.PostTypeId ORDER BY p.Score DESC) AS PostRank,
        COUNT(c.Id) AS CommentCount,
        CASE 
            WHEN p.AcceptedAnswerId IS NOT NULL THEN 1 
            ELSE 0 
        END AS IsAnswered
    FROM 
        Posts p
    LEFT JOIN 
        Comments c ON p.Id = c.PostId
    WHERE 
        p.CreationDate > DATE_SUB(CURRENT_DATE(), INTERVAL 1 YEAR)
    GROUP BY 
        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, p.AcceptedAnswerId, p.PostTypeId
), PostWithBadges AS (
    SELECT 
        rp.PostId,
        rp.Title,
        rp.CreationDate,
        rp.ViewCount,
        rp.Score,
        rp.CommentCount,
        rb.UserId AS OwnerId,
        b.Name AS BadgeName,
        CASE 
            WHEN rb.Id IS NOT NULL THEN 1 
            ELSE 0 
        END AS HasBadge
    FROM 
        RankedPosts rp
    LEFT JOIN 
        Users rb ON rb.Id = rp.PostId
    LEFT JOIN 
        Badges b ON b.UserId = rb.Id AND b.Class = 1 
)
SELECT 
    pwb.PostId, 
    pwb.Title,
    pwb.CreationDate,
    pwb.ViewCount,
    pwb.Score,
    pwb.CommentCount,
    pwb.BadgeName,
    pwb.HasBadge,
    COALESCE((SELECT STRING_AGG(t.TagName, ', ') FROM Tags t JOIN Posts p ON t.ExcerptPostId = p.Id WHERE p.Id = pwb.PostId), 'No Tags') AS Tags,
    CASE 
        WHEN pwb.CommentCount > 10 AND pwb.HasBadge = 1 THEN 'Popular with Badge'
        WHEN pwb.CommentCount > 10 THEN 'Popular Post'
        WHEN pwb.HasBadge = 1 THEN 'Post with Badge'
        ELSE 'Regular Post'
    END AS PopularityStatus
FROM 
    PostWithBadges pwb
WHERE 
    pwb.PostId IN (
        SELECT 
            p.Id 
        FROM 
            Posts p 
        WHERE 
            p.LastActivityDate >= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)
            AND p.ViewCount IS NOT NULL
    ) 
    OR pwb.HasBadge = 1
ORDER BY 
    pwb.Score DESC, 
    pwb.CommentCount DESC;
