WITH RecursivePostHierarchy AS (
    SELECT 
        p.Id AS PostId,
        p.Title,
        p.ParentId,
        p.CreationDate,
        0 AS Level
    FROM 
        Posts p
    WHERE 
        p.ParentId IS NULL  

    UNION ALL

    SELECT 
        p.Id,
        p.Title,
        p.ParentId,
        p.CreationDate,
        r.Level + 1
    FROM 
        Posts p
    JOIN 
        RecursivePostHierarchy r ON p.ParentId = r.PostId
),
PostStats AS (
    SELECT 
        p.PostId,
        p.Title,
        COUNT(c.Id) AS CommentCount,
        SUM(v.BountyAmount) AS TotalBounties,
        AVG(v.BountyAmount) AS AverageBounty,
        ROW_NUMBER() OVER (PARTITION BY p.PostId ORDER BY COUNT(c.Id) DESC) AS Rank
    FROM 
        Posts p
    LEFT JOIN 
        Comments c ON c.PostId = p.Id
    LEFT JOIN 
        Votes v ON v.PostId = p.Id AND v.VoteTypeId = 8 
    GROUP BY 
        p.PostId, p.Title
),
PopularTags AS (
    SELECT 
        t.TagName,
        COUNT(p.Id) AS PostCount
    FROM 
        Tags t
    JOIN 
        Posts p ON t.Id = ANY(string_to_array(substring(p.Tags, 2, length(p.Tags) - 2), '><')::int[])
    GROUP BY 
        t.TagName
    HAVING 
        COUNT(p.Id) > 5  
),
LatestPostHistory AS (
    SELECT 
        ph.PostId,
        MAX(ph.CreationDate) AS LatestEditDate
    FROM 
        PostHistory ph
    GROUP BY 
        ph.PostId
)
SELECT 
    p.Id AS PostId,
    p.Title,
    p.CreationDate AS PostCreationDate,
    r.Level AS HierarchyLevel,
    ps.CommentCount,
    ps.TotalBounties,
    ps.AverageBounty,
    pt.TagName,
    lph.LatestEditDate,
    CASE 
        WHEN lph.LatestEditDate IS NOT NULL THEN 'Edited'
        ELSE 'Not Edited'
    END AS EditStatus
FROM 
    Posts p
LEFT JOIN 
    RecursivePostHierarchy r ON p.Id = r.PostId
LEFT JOIN 
    PostStats ps ON ps.PostId = p.Id
LEFT JOIN 
    PopularTags pt ON pt.PostCount > 5
LEFT JOIN 
    LatestPostHistory lph ON lph.PostId = p.Id
WHERE 
    (ps.CommentCount > 0 OR ps.TotalBounties > 0)  
ORDER BY 
    ps.CommentCount DESC, ps.TotalBounties DESC;