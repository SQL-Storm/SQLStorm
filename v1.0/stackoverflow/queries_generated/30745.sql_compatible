
WITH RecursivePostHistory AS (
    SELECT 
        ph.PostId,
        ph.RevisionGUID,
        ph.UserId,
        ph.UserDisplayName,
        ph.CreationDate,
        ph.Comment,
        1 AS Level
    FROM 
        PostHistory ph
    WHERE 
        ph.PostHistoryTypeId IN (1, 3)  

    UNION ALL

    SELECT 
        ph.PostId,
        ph.RevisionGUID,
        ph.UserId,
        ph.UserDisplayName,
        ph.CreationDate,
        ph.Comment,
        rph.Level + 1
    FROM 
        PostHistory ph
    INNER JOIN 
        RecursivePostHistory rph ON ph.PostId = rph.PostId 
    WHERE 
        ph.CreationDate < rph.CreationDate
)

SELECT 
    p.Id AS PostId,
    p.Title,
    COUNT(DISTINCT rph.RevisionGUID) AS RevisionCount,
    SUM(CASE WHEN rph.UserId IS NOT NULL THEN 1 ELSE 0 END) AS UniqueEditors,
    MAX(rph.CreationDate) AS LastRevisionDate,
    AVG(u.Reputation) AS AverageEditorReputation,
    STRING_AGG(DISTINCT t.TagName, ', ') AS Tags,
    CASE 
        WHEN COUNT(DISTINCT v.Id) > 50 THEN 'Highly Voted'
        WHEN COUNT(DISTINCT v.Id) BETWEEN 20 AND 50 THEN 'Moderately Voted'
        ELSE 'Low Votes'
    END AS VoteCategory
FROM 
    Posts p
LEFT JOIN 
    RecursivePostHistory rph ON p.Id = rph.PostId
LEFT JOIN 
    Users u ON rph.UserId = u.Id
LEFT JOIN 
    Votes v ON p.Id = v.PostId AND v.VoteTypeId IN (2, 3) 
LEFT JOIN 
    Tags t ON t.Id = ANY(STRING_TO_ARRAY(p.Tags,',')::int[]) 
WHERE 
    p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'  
GROUP BY 
    p.Id, p.Title
ORDER BY 
    RevisionCount DESC, AverageEditorReputation DESC;
