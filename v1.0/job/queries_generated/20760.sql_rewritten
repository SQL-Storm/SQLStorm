WITH RECURSIVE ActorHierarchy AS (
    SELECT 
        a.id AS actor_id,
        a.name AS actor_name,
        c.movie_id,
        1 AS depth
    FROM 
        aka_name a
    JOIN 
        cast_info ci ON a.person_id = ci.person_id
    JOIN 
        aka_title t ON ci.movie_id = t.movie_id
    WHERE 
        t.production_year IS NOT NULL
    
    UNION ALL

    SELECT 
        a.id AS actor_id,
        a.name AS actor_name,
        c.movie_id,
        h.depth + 1
    FROM 
        ActorHierarchy h
    JOIN 
        cast_info ci ON h.movie_id = ci.movie_id
    JOIN 
        aka_name a ON ci.person_id = a.person_id
    WHERE 
        h.depth < 5  
),

AggregatedRoles AS (
    SELECT 
        actor_id,
        actor_name,
        COUNT(DISTINCT movie_id) AS movie_count,
        STRING_AGG(DISTINCT t.title, ', ') AS roles
    FROM 
        ActorHierarchy h
    JOIN 
        aka_title t ON h.movie_id = t.id
    GROUP BY 
        actor_id, actor_name
),

FilteredResults AS (
    SELECT 
        a.actor_id,
        a.actor_name,
        a.movie_count,
        a.roles,
        RANK() OVER (PARTITION BY a.movie_count ORDER BY a.actor_name DESC) AS rank_order
    FROM 
        AggregatedRoles a
    WHERE 
        a.movie_count > 3
        AND a.actor_name IS NOT NULL
)

SELECT 
    fr.actor_id,
    fr.actor_name,
    fr.movie_count,
    fr.roles,
    COALESCE(SUBSTRING(fr.roles FROM '[^,]+'), 'No roles found') AS first_role,
    CASE 
        WHEN fr.movie_count > 10 THEN 'Frequent Actor'
        WHEN fr.movie_count BETWEEN 5 AND 10 THEN 'Regular Actor'
        ELSE 'Occasional Actor'
    END AS actor_frequency_classification,
    STRING_AGG(DISTINCT ci.note, ';') AS cast_notes
FROM 
    FilteredResults fr
LEFT OUTER JOIN 
    cast_info ci ON fr.actor_id = ci.person_id 
GROUP BY 
    fr.actor_id, fr.actor_name, fr.movie_count, fr.roles
HAVING 
    COUNT(ci.note) > 0 OR fr.actor_name IS NULL 
ORDER BY 
    fr.rank_order, fr.actor_name;