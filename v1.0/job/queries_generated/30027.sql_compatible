
WITH RECURSIVE MovieHierarchy AS (
    SELECT 
        m.id AS movie_id,
        m.title,
        m.production_year,
        NULL AS parent_title,
        1 AS depth
    FROM 
        aka_title m
    WHERE 
        m.episode_of_id IS NULL  
    UNION ALL
    SELECT 
        e.id AS movie_id,
        e.title,
        e.production_year,
        m.title AS parent_title,
        mh.depth + 1
    FROM 
        aka_title e
    JOIN 
        MovieHierarchy mh ON e.episode_of_id = mh.movie_id
), 

CastDetails AS (
    SELECT 
        a.id AS actor_id,
        a.name,
        c.movie_id,
        ROW_NUMBER() OVER (PARTITION BY c.movie_id ORDER BY a.name) AS actor_rank
    FROM 
        aka_name a
    JOIN 
        cast_info c ON a.person_id = c.person_id
    WHERE
        c.role_id IN (SELECT id FROM role_type WHERE role LIKE 'Actor%')  
), 

MoviesWithCompany AS (
    SELECT 
        mh.movie_id,
        mh.title,
        mh.production_year,
        COUNT(DISTINCT mc.company_id) AS company_count
    FROM 
        MovieHierarchy mh
    LEFT JOIN 
        movie_companies mc ON mh.movie_id = mc.movie_id
    GROUP BY 
        mh.movie_id, mh.title, mh.production_year
)

SELECT 
    mwc.movie_id,
    mwc.title,
    mwc.production_year,
    mwc.company_count,
    json_agg(DISTINCT json_build_object(
        'actor_id', cd.actor_id,
        'actor_name', cd.name,
        'actor_rank', cd.actor_rank
    )) AS actors,
    CASE 
        WHEN mwc.company_count > 0 THEN 'Has Companies' 
        ELSE 'No Companies' 
    END AS company_status,
    COALESCE((
        SELECT STRING_AGG(DISTINCT kw.keyword, ', ') 
        FROM movie_keyword mk 
        JOIN keyword kw ON mk.keyword_id = kw.id 
        WHERE mk.movie_id = mwc.movie_id
    ), 'No Keywords') AS keywords
FROM 
    MoviesWithCompany mwc
LEFT JOIN 
    CastDetails cd ON mwc.movie_id = cd.movie_id
GROUP BY 
    mwc.movie_id, mwc.title, mwc.production_year, mwc.company_count
ORDER BY 
    mwc.production_year DESC, mwc.title;
