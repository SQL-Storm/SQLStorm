WITH RECURSIVE NestedTitles AS (
    SELECT 
        t.id AS title_id,
        t.title AS title,
        t.production_year,
        0 AS recursion_level
    FROM 
        aka_title t
    WHERE 
        t.production_year IS NOT NULL
    
    UNION ALL

    SELECT 
        t.id AS title_id,
        t.title AS title,
        t.production_year,
        nt.recursion_level + 1
    FROM 
        aka_title t
    JOIN 
        NestedTitles nt ON t.episode_of_id = nt.title_id
    WHERE 
        nt.recursion_level < 3  
),
AggregateNames AS (
    SELECT 
        a.person_id,
        STRING_AGG(a.name, ', ' ORDER BY a.name) AS all_names
    FROM 
        aka_name a
    GROUP BY 
        a.person_id
),
CompaniesWithTitles AS (
    SELECT 
        mc.movie_id,
        COUNT(DISTINCT c.id) AS company_count,
        STRING_AGG(DISTINCT co.name, ', ') AS company_names
    FROM 
        movie_companies mc
    JOIN 
        company_name co ON mc.company_id = co.id
    GROUP BY 
        mc.movie_id
)
SELECT 
    nt.title_id,
    nt.title,
    nt.production_year,
    COALESCE(an.all_names, 'Unknown') AS all_names,
    cwt.company_count,
    COALESCE(cwt.company_names, 'No Companies') AS company_names,
    ROW_NUMBER() OVER (PARTITION BY nt.production_year ORDER BY nt.title) AS year_rank,
    CASE 
        WHEN nt.production_year < 2000 THEN 'Classic'
        WHEN nt.production_year BETWEEN 2000 AND 2010 THEN 'Modern'
        ELSE 'Recent'
    END AS era_category
FROM 
    NestedTitles nt
LEFT OUTER JOIN 
    AggregateNames an ON nt.title_id IN (SELECT movie_id FROM cast_info WHERE person_id = an.person_id)
LEFT JOIN 
    CompaniesWithTitles cwt ON nt.title_id = cwt.movie_id
WHERE 
    (nt.production_year IS NOT NULL OR nt.production_year IS NOT NULL)  
    AND (cwt.company_count IS NULL OR cwt.company_count > 0)  
ORDER BY 
    era_category,
    nt.production_year DESC;