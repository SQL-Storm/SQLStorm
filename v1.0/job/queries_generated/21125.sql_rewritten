WITH recursive movie_hierarchy AS (
    SELECT mt.id AS movie_id, 
           mt.title, 
           mt.production_year, 
           NULL::integer AS parent_movie_id
    FROM aka_title mt
    WHERE mt.kind_id IN (SELECT id FROM kind_type WHERE kind = 'movie')

    UNION ALL

    SELECT mt.id AS movie_id, 
           mt.title, 
           mt.production_year, 
           mh.movie_id AS parent_movie_id
    FROM aka_title mt
    JOIN movie_link ml ON ml.linked_movie_id = mt.id
    JOIN movie_hierarchy mh ON mh.movie_id = ml.movie_id
)

SELECT 
    distinct an.person_id, 
    an.name AS actor_name, 
    m.title AS movie_title, 
    mh.title AS linked_title,
    m.production_year,
    COALESCE(k.keyword, 'No Keyword') AS movie_keyword,
    count(DISTINCT c.movie_id) OVER (PARTITION BY an.person_id) AS total_movies,
    row_number() OVER (PARTITION BY an.person_id ORDER BY count(DISTINCT c.movie_id) DESC) AS rank
FROM aka_name an
JOIN cast_info c ON an.person_id = c.person_id
JOIN aka_title m ON c.movie_id = m.id
LEFT JOIN movie_keyword mk ON m.id = mk.movie_id
LEFT JOIN keyword k ON mk.keyword_id = k.id
LEFT JOIN movie_hierarchy mh ON mh.movie_id = m.id
WHERE m.production_year IS NOT NULL 
  AND m.production_year >= 2000 
  AND (k.keyword IS NULL OR k.keyword NOT LIKE 'Action%')
  AND EXISTS (
      SELECT 1
      FROM complete_cast cc 
      JOIN movie_info mi ON mi.movie_id = m.id
      WHERE cc.movie_id = m.id
        AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Budget')
        AND mi.info IS NOT NULL
      LIMIT 1
  )
ORDER BY total_movies DESC, an.name;