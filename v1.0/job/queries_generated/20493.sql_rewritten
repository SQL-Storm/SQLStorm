WITH RECURSIVE movie_hierarchy AS (
    SELECT
        mt.id AS movie_id,
        mt.title,
        mt.production_year,
        0 AS level,
        NULL::integer AS parent_id
    FROM aka_title mt
    WHERE mt.production_year = (SELECT MAX(production_year) FROM aka_title)

    UNION ALL

    SELECT
        mk.movie_id,
        mt.title,
        mt.production_year,
        mh.level + 1,
        mh.movie_id AS parent_id
    FROM movie_link ml
    JOIN movie_hierarchy mh ON ml.movie_id = mh.movie_id
    JOIN aka_title mt ON ml.linked_movie_id = mt.id
)

SELECT
    a.name,
    m.title,
    m.production_year,
    mp.company_id,
    c.name as company_name,
    a.name_pcode_cf AS aka_code,
    COALESCE(NULLIF(eepk.id, 0), NULL) AS episode_id,
    COUNT(DISTINCT ci.id) OVER (PARTITION BY m.id) AS cast_count,
    STRING_AGG(DISTINCT k.keyword, ', ') FILTER (WHERE k.keyword IS NOT NULL) AS keywords,
    AVG(info.info_length) AS avg_info_length
FROM aka_name a
JOIN cast_info ci ON a.person_id = ci.person_id
JOIN aka_title m ON ci.movie_id = m.id
LEFT JOIN movie_companies mp ON m.id = mp.movie_id
LEFT JOIN company_name c ON mp.company_id = c.id
LEFT JOIN (SELECT movie_id, LENGTH(info) AS info_length
            FROM movie_info
            WHERE info IS NOT NULL) info ON m.id = info.movie_id
LEFT JOIN (SELECT id, movie_id 
             FROM title 
             WHERE season_nr IS NOT NULL) eepk ON m.id = eepk.id
LEFT JOIN movie_keyword mk ON m.id = mk.movie_id
LEFT JOIN keyword k ON mk.keyword_id = k.id
WHERE m.production_year IS NOT NULL
  AND (m.note IS NULL OR m.note <> 'No note')
  AND NOT EXISTS (
      SELECT 1 
      FROM movie_info_idx mi 
      WHERE mi.movie_id = m.id AND mi.info ILIKE '%unrated%'
  )
GROUP BY
    a.name,
    m.title,
    m.production_year,
    mp.company_id,
    c.name,
    aka_code,
    eepk.id
HAVING COUNT(DISTINCT ci.id) > 0
ORDER BY
    m.production_year DESC,
    cast_count DESC nulls last;