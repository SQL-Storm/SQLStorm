
WITH RECURSIVE customer_orders AS (
    SELECT c.c_custkey, c.c_name, o.o_orderkey, o.o_orderdate, o.o_totalprice, 1 AS depth
    FROM customer c
    JOIN orders o ON c.c_custkey = o.o_custkey
    WHERE o.o_orderdate >= '1996-01-01' AND o.o_orderdate < '1997-01-01'
    UNION ALL
    SELECT co.c_custkey, co.c_name, o.o_orderkey, o.o_orderdate, o.o_totalprice, co.depth + 1
    FROM customer_orders co
    JOIN orders o ON co.c_custkey = o.o_custkey
    WHERE o.o_orderdate > '1997-01-01' AND o.o_orderdate < DATEADD(year, co.depth, '1996-01-01')
),
supplier_part AS (
    SELECT s.s_suppkey, s.s_name, ps.ps_partkey, SUM(ps.ps_availqty) AS total_avail
    FROM supplier s
    JOIN partsupp ps ON s.s_suppkey = ps.ps_suppkey
    GROUP BY s.s_suppkey, s.s_name, ps.ps_partkey
),
price_stats AS (
    SELECT p.p_partkey, p.p_name, p.p_retailprice,
           ROW_NUMBER() OVER (PARTITION BY p.p_brand ORDER BY p.p_retailprice DESC) AS rn
    FROM part p
)
SELECT DISTINCT
    co.c_name,
    SUM(CASE WHEN l.l_returnflag = 'R' THEN l.l_extendedprice * (1 - l.l_discount) END) AS total_refunds,
    AVG(sp.total_avail) AS avg_avail_per_supplier,
    (SELECT COUNT(DISTINCT s.s_suppkey)
     FROM supplier s
     JOIN supplier_part sp ON s.s_suppkey = sp.s_suppkey 
     WHERE sp.total_avail > (SELECT AVG(total_avail) FROM supplier_part)
    ) AS suppliers_above_avg,
    p.p_name,
    CASE
        WHEN p.p_retailprice IS NULL THEN 'No Price'
        WHEN p.p_retailprice > (SELECT MAX(p2.p_retailprice) FROM part p2 WHERE p2.p_type = p.p_type) THEN 'Expensive'
        ELSE 'Affordable'
    END AS price_category
FROM customer_orders co
LEFT JOIN lineitem l ON co.o_orderkey = l.l_orderkey
JOIN supplier_part sp ON l.l_suppkey = sp.s_suppkey
JOIN price_stats p ON sp.ps_partkey = p.p_partkey
WHERE co.depth < 3 AND (l.l_shipmode = 'TRUCK' OR l.l_shipmode = 'SHIP')
GROUP BY co.c_name, p.p_name, p.p_retailprice
HAVING SUM(CASE WHEN l.l_returnflag = 'R' THEN 1 ELSE 0 END) > 10
ORDER BY total_refunds DESC, avg_avail_per_supplier ASC;
